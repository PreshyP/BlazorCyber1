"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegistryResponseError = exports.parsePref = exports.NoMatchingVersionError = void 0;
const path_1 = __importDefault(require("path"));
const error_1 = __importDefault(require("@pnpm/error"));
const resolve_workspace_range_1 = __importDefault(require("@pnpm/resolve-workspace-range"));
const lru_cache_1 = __importDefault(require("lru-cache"));
const normalize_path_1 = __importDefault(require("normalize-path"));
const p_memoize_1 = __importDefault(require("p-memoize"));
const clone_1 = __importDefault(require("ramda/src/clone"));
const semver_1 = __importDefault(require("semver"));
const ssri_1 = __importDefault(require("ssri"));
const pickPackage_1 = __importDefault(require("./pickPackage"));
const parsePref_1 = __importDefault(require("./parsePref"));
exports.parsePref = parsePref_1.default;
const fetch_1 = __importStar(require("./fetch"));
Object.defineProperty(exports, "RegistryResponseError", { enumerable: true, get: function () { return fetch_1.RegistryResponseError; } });
const createNpmPkgId_1 = __importDefault(require("./createNpmPkgId"));
const workspacePrefToNpm_1 = __importDefault(require("./workspacePrefToNpm"));
class NoMatchingVersionError extends error_1.default {
    constructor(opts) {
        const dep = opts.wantedDependency.alias
            ? `${opts.wantedDependency.alias}@${opts.wantedDependency.pref ?? ''}`
            : opts.wantedDependency.pref;
        super('NO_MATCHING_VERSION', `No matching version found for ${dep}`);
        this.packageMeta = opts.packageMeta;
    }
}
exports.NoMatchingVersionError = NoMatchingVersionError;
// This file contains meta information
// about all the packages published by the same name, not just the manifest
// of one package/version
const META_DIR = 'metadata';
const FULL_META_DIR = 'metadata-full';
const FULL_FILTERED_META_DIR = 'metadata-v1.1';
function createResolver(fetchFromRegistry, getCredentials, opts) {
    if (typeof opts.cacheDir !== 'string') {
        throw new TypeError('`opts.cacheDir` is required and needs to be a string');
    }
    const fetchOpts = {
        retry: opts.retry ?? {},
        timeout: opts.timeout ?? 60000,
    };
    const fetch = (0, p_memoize_1.default)(fetch_1.default.bind(null, fetchFromRegistry, fetchOpts), {
        cacheKey: (...args) => JSON.stringify(args),
        maxAge: 1000 * 20, // 20 seconds
    });
    const getAuthHeaderValueByURI = (registry) => getCredentials(registry).authHeaderValue;
    const metaCache = new lru_cache_1.default({
        max: 10000,
        ttl: 120 * 1000, // 2 minutes
    });
    return resolveNpm.bind(null, {
        getAuthHeaderValueByURI,
        pickPackage: pickPackage_1.default.bind(null, {
            fetch,
            filterMetadata: opts.filterMetadata,
            metaCache,
            metaDir: opts.fullMetadata ? (opts.filterMetadata ? FULL_FILTERED_META_DIR : FULL_META_DIR) : META_DIR,
            offline: opts.offline,
            preferOffline: opts.preferOffline,
            cacheDir: opts.cacheDir,
        }),
    });
}
exports.default = createResolver;
async function resolveNpm(ctx, wantedDependency, opts) {
    const defaultTag = opts.defaultTag ?? 'latest';
    if (wantedDependency.pref?.startsWith('workspace:')) {
        if (wantedDependency.pref.startsWith('workspace:.'))
            return null;
        const resolvedFromWorkspace = tryResolveFromWorkspace(wantedDependency, {
            defaultTag,
            lockfileDir: opts.lockfileDir,
            projectDir: opts.projectDir,
            registry: opts.registry,
            workspacePackages: opts.workspacePackages,
        });
        if (resolvedFromWorkspace != null) {
            return resolvedFromWorkspace;
        }
    }
    const workspacePackages = opts.alwaysTryWorkspacePackages !== false ? opts.workspacePackages : undefined;
    const spec = wantedDependency.pref
        ? (0, parsePref_1.default)(wantedDependency.pref, wantedDependency.alias, defaultTag, opts.registry)
        : defaultTagForAlias(wantedDependency.alias, defaultTag);
    if (spec == null)
        return null;
    const authHeaderValue = ctx.getAuthHeaderValueByURI(opts.registry);
    let pickResult;
    try {
        pickResult = await ctx.pickPackage(spec, {
            pickLowestVersion: opts.pickLowestVersion,
            publishedBy: opts.publishedBy,
            authHeaderValue,
            dryRun: opts.dryRun === true,
            preferredVersionSelectors: opts.preferredVersions?.[spec.name],
            registry: opts.registry,
        });
    }
    catch (err) { // eslint-disable-line
        if ((workspacePackages != null) && opts.projectDir) {
            const resolvedFromLocal = tryResolveFromWorkspacePackages(workspacePackages, spec, {
                projectDir: opts.projectDir,
                lockfileDir: opts.lockfileDir,
                hardLinkLocalPackages: wantedDependency.injected,
            });
            if (resolvedFromLocal != null)
                return resolvedFromLocal;
        }
        throw err;
    }
    const pickedPackage = pickResult.pickedPackage;
    const meta = pickResult.meta;
    if (pickedPackage == null) {
        if ((workspacePackages != null) && opts.projectDir) {
            const resolvedFromLocal = tryResolveFromWorkspacePackages(workspacePackages, spec, {
                projectDir: opts.projectDir,
                lockfileDir: opts.lockfileDir,
                hardLinkLocalPackages: wantedDependency.injected,
            });
            if (resolvedFromLocal != null)
                return resolvedFromLocal;
        }
        throw new NoMatchingVersionError({ wantedDependency, packageMeta: meta });
    }
    if (((workspacePackages?.[pickedPackage.name]) != null) && opts.projectDir) {
        if (workspacePackages[pickedPackage.name][pickedPackage.version]) {
            return {
                ...resolveFromLocalPackage(workspacePackages[pickedPackage.name][pickedPackage.version], spec.normalizedPref, {
                    projectDir: opts.projectDir,
                    lockfileDir: opts.lockfileDir,
                    hardLinkLocalPackages: wantedDependency.injected,
                }),
                latest: meta['dist-tags'].latest,
            };
        }
        const localVersion = pickMatchingLocalVersionOrNull(workspacePackages[pickedPackage.name], spec);
        if (localVersion && (semver_1.default.gt(localVersion, pickedPackage.version) || opts.preferWorkspacePackages)) {
            return {
                ...resolveFromLocalPackage(workspacePackages[pickedPackage.name][localVersion], spec.normalizedPref, {
                    projectDir: opts.projectDir,
                    lockfileDir: opts.lockfileDir,
                    hardLinkLocalPackages: wantedDependency.injected,
                }),
                latest: meta['dist-tags'].latest,
            };
        }
    }
    const id = (0, createNpmPkgId_1.default)(pickedPackage.dist.tarball, pickedPackage.name, pickedPackage.version);
    const resolution = {
        integrity: getIntegrity(pickedPackage.dist),
        registry: opts.registry,
        tarball: pickedPackage.dist.tarball,
    };
    return {
        id,
        latest: meta['dist-tags'].latest,
        manifest: pickedPackage,
        normalizedPref: spec.normalizedPref,
        resolution,
        resolvedVia: 'npm-registry',
        publishedAt: meta.time?.[pickedPackage.version],
    };
}
function tryResolveFromWorkspace(wantedDependency, opts) {
    if (!wantedDependency.pref?.startsWith('workspace:')) {
        return null;
    }
    const pref = (0, workspacePrefToNpm_1.default)(wantedDependency.pref);
    const spec = (0, parsePref_1.default)(pref, wantedDependency.alias, opts.defaultTag, opts.registry);
    if (spec == null)
        throw new Error(`Invalid workspace: spec (${wantedDependency.pref})`);
    if (opts.workspacePackages == null) {
        throw new Error('Cannot resolve package from workspace because opts.workspacePackages is not defined');
    }
    if (!opts.projectDir) {
        throw new Error('Cannot resolve package from workspace because opts.projectDir is not defined');
    }
    const resolvedFromLocal = tryResolveFromWorkspacePackages(opts.workspacePackages, spec, {
        projectDir: opts.projectDir,
        hardLinkLocalPackages: wantedDependency.injected,
        lockfileDir: opts.lockfileDir,
    });
    if (resolvedFromLocal == null) {
        throw new error_1.default('NO_MATCHING_VERSION_INSIDE_WORKSPACE', `In ${path_1.default.relative(process.cwd(), opts.projectDir)}: No matching version found for ${wantedDependency.alias ?? ''}@${pref} inside the workspace`);
    }
    return resolvedFromLocal;
}
function tryResolveFromWorkspacePackages(workspacePackages, spec, opts) {
    if (!workspacePackages[spec.name])
        return null;
    const localVersion = pickMatchingLocalVersionOrNull(workspacePackages[spec.name], spec);
    if (!localVersion)
        return null;
    return resolveFromLocalPackage(workspacePackages[spec.name][localVersion], spec.normalizedPref, opts);
}
function pickMatchingLocalVersionOrNull(versions, spec) {
    const localVersions = Object.keys(versions);
    switch (spec.type) {
        case 'tag':
            return semver_1.default.maxSatisfying(localVersions, '*');
        case 'version':
            return versions[spec.fetchSpec] ? spec.fetchSpec : null;
        case 'range':
            return (0, resolve_workspace_range_1.default)(spec.fetchSpec, localVersions);
        default:
            return null;
    }
}
function resolveFromLocalPackage(localPackage, normalizedPref, opts) {
    let id;
    let directory;
    const localPackageDir = resolveLocalPackageDir(localPackage);
    if (opts.hardLinkLocalPackages) {
        directory = (0, normalize_path_1.default)(path_1.default.relative(opts.lockfileDir, localPackageDir));
        id = `file:${directory}`;
    }
    else {
        directory = localPackageDir;
        id = `link:${(0, normalize_path_1.default)(path_1.default.relative(opts.projectDir, localPackageDir))}`;
    }
    return {
        id,
        manifest: (0, clone_1.default)(localPackage.manifest),
        normalizedPref,
        resolution: {
            directory,
            type: 'directory',
        },
        resolvedVia: 'local-filesystem',
    };
}
function resolveLocalPackageDir(localPackage) {
    if (localPackage.manifest.publishConfig?.directory == null ||
        localPackage.manifest.publishConfig?.linkDirectory !== true)
        return localPackage.dir;
    return path_1.default.join(localPackage.dir, localPackage.manifest.publishConfig.directory);
}
function defaultTagForAlias(alias, defaultTag) {
    return {
        fetchSpec: defaultTag,
        name: alias,
        type: 'tag',
    };
}
function getIntegrity(dist) {
    if (dist.integrity) {
        return dist.integrity;
    }
    if (!dist.shasum) {
        return undefined;
    }
    const integrity = ssri_1.default.fromHex(dist.shasum, 'sha1');
    if (!integrity) {
        throw new error_1.default('INVALID_TARBALL_INTEGRITY', `Tarball "${dist.tarball}" has invalid shasum specified in its metadata: ${dist.shasum}`);
    }
    return integrity.toString();
}
//# sourceMappingURL=index.js.map