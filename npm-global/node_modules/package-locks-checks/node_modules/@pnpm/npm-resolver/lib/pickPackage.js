"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = __importDefault(require("crypto"));
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const error_1 = __importDefault(require("@pnpm/error"));
const logger_1 = __importDefault(require("@pnpm/logger"));
const graceful_fs_1 = __importDefault(require("@pnpm/graceful-fs"));
const encode_registry_1 = __importDefault(require("encode-registry"));
const load_json_file_1 = __importDefault(require("load-json-file"));
const p_limit_1 = __importDefault(require("p-limit"));
const path_temp_1 = __importDefault(require("path-temp"));
const pick_1 = __importDefault(require("ramda/src/pick"));
const rename_overwrite_1 = __importDefault(require("rename-overwrite"));
const toRaw_1 = __importDefault(require("./toRaw"));
const pickPackageFromMeta_1 = require("./pickPackageFromMeta");
/**
 * prevents simultaneous operations on the meta.json
 * otherwise it would cause EPERM exceptions
 */
const metafileOperationLimits = {};
function pickPackageFromMetaUsingTime(spec, preferredVersionSelectors, meta, publishedBy) {
    const pickedPackage = (0, pickPackageFromMeta_1.pickPackageFromMeta)(pickPackageFromMeta_1.pickVersionByVersionRange, spec, preferredVersionSelectors, meta, publishedBy);
    if (pickedPackage)
        return pickedPackage;
    return (0, pickPackageFromMeta_1.pickPackageFromMeta)(pickPackageFromMeta_1.pickLowestVersionByVersionRange, spec, preferredVersionSelectors, meta, publishedBy);
}
exports.default = async (ctx, spec, opts) => {
    opts = opts || {};
    const _pickPackageFromMeta = opts.publishedBy
        ? pickPackageFromMetaUsingTime
        : (pickPackageFromMeta_1.pickPackageFromMeta.bind(null, opts.pickLowestVersion ? pickPackageFromMeta_1.pickLowestVersionByVersionRange : pickPackageFromMeta_1.pickVersionByVersionRange));
    validatePackageName(spec.name);
    const cachedMeta = ctx.metaCache.get(spec.name);
    if (cachedMeta != null) {
        return {
            meta: cachedMeta,
            pickedPackage: _pickPackageFromMeta(spec, opts.preferredVersionSelectors, cachedMeta, opts.publishedBy),
        };
    }
    const registryName = (0, encode_registry_1.default)(opts.registry);
    const pkgMirror = path_1.default.join(ctx.cacheDir, ctx.metaDir, registryName, `${encodePkgName(spec.name)}.json`);
    const limit = metafileOperationLimits[pkgMirror] = metafileOperationLimits[pkgMirror] || (0, p_limit_1.default)(1);
    let metaCachedInStore;
    if (ctx.offline === true || ctx.preferOffline === true || opts.pickLowestVersion) {
        metaCachedInStore = await limit(async () => loadMeta(pkgMirror));
        if (ctx.offline) {
            if (metaCachedInStore != null)
                return {
                    meta: metaCachedInStore,
                    pickedPackage: _pickPackageFromMeta(spec, opts.preferredVersionSelectors, metaCachedInStore, opts.publishedBy),
                };
            throw new error_1.default('NO_OFFLINE_META', `Failed to resolve ${(0, toRaw_1.default)(spec)} in package mirror ${pkgMirror}`);
        }
        if (metaCachedInStore != null) {
            const pickedPackage = _pickPackageFromMeta(spec, opts.preferredVersionSelectors, metaCachedInStore, opts.publishedBy);
            if (pickedPackage) {
                return {
                    meta: metaCachedInStore,
                    pickedPackage,
                };
            }
        }
    }
    if (spec.type === 'version') {
        metaCachedInStore = metaCachedInStore ?? await limit(async () => loadMeta(pkgMirror));
        // use the cached meta only if it has the required package version
        // otherwise it is probably out of date
        if ((metaCachedInStore?.versions?.[spec.fetchSpec]) != null) {
            return {
                meta: metaCachedInStore,
                pickedPackage: metaCachedInStore.versions[spec.fetchSpec],
            };
        }
    }
    if (opts.publishedBy) {
        metaCachedInStore = metaCachedInStore ?? await limit(async () => loadMeta(pkgMirror));
        if (metaCachedInStore?.cachedAt && new Date(metaCachedInStore.cachedAt) >= opts.publishedBy) {
            const pickedPackage = _pickPackageFromMeta(spec, opts.preferredVersionSelectors, metaCachedInStore, opts.publishedBy);
            if (pickedPackage) {
                return {
                    meta: metaCachedInStore,
                    pickedPackage,
                };
            }
        }
    }
    try {
        let meta = await ctx.fetch(spec.name, opts.registry, opts.authHeaderValue);
        if (ctx.filterMetadata) {
            meta = clearMeta(meta);
        }
        meta.cachedAt = Date.now();
        // only save meta to cache, when it is fresh
        ctx.metaCache.set(spec.name, meta);
        if (!opts.dryRun) {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            limit(async () => {
                try {
                    await saveMeta(pkgMirror, meta);
                }
                catch (err) { // eslint-disable-line
                    // We don't care if this file was not written to the cache
                }
            });
        }
        return {
            meta,
            pickedPackage: _pickPackageFromMeta(spec, opts.preferredVersionSelectors, meta, opts.publishedBy),
        };
    }
    catch (err) { // eslint-disable-line
        err.spec = spec;
        const meta = await loadMeta(pkgMirror); // TODO: add test for this usecase
        if (meta == null)
            throw err;
        logger_1.default.error(err, err);
        logger_1.default.debug({ message: `Using cached meta from ${pkgMirror}` });
        return {
            meta,
            pickedPackage: _pickPackageFromMeta(spec, opts.preferredVersionSelectors, meta, opts.publishedBy),
        };
    }
};
function clearMeta(pkg) {
    const versions = {};
    for (const [version, info] of Object.entries(pkg.versions)) {
        // The list taken from https://github.com/npm/registry/blob/master/docs/responses/package-metadata.md#abbreviated-version-object
        versions[version] = (0, pick_1.default)([
            'name',
            'version',
            'bin',
            'directories',
            'devDependencies',
            'optionalDependencies',
            'dependencies',
            'peerDependencies',
            'dist',
            'engines',
            'peerDependenciesMeta',
            'cpu',
            'os',
            'deprecated',
            'bundleDependencies',
            'bundledDependencies',
            'hasInstallScript',
        ], info);
    }
    return {
        name: pkg.name,
        'dist-tags': pkg['dist-tags'],
        versions,
        time: pkg.time,
        cachedAt: pkg.cachedAt,
    };
}
function encodePkgName(pkgName) {
    if (pkgName !== pkgName.toLowerCase()) {
        return `${pkgName}_${crypto_1.default.createHash('md5').update(pkgName).digest('hex')}`;
    }
    return pkgName;
}
async function loadMeta(pkgMirror) {
    try {
        return await (0, load_json_file_1.default)(pkgMirror);
    }
    catch (err) { // eslint-disable-line
        return null;
    }
}
const createdDirs = new Set();
async function saveMeta(pkgMirror, meta) {
    const dir = path_1.default.dirname(pkgMirror);
    if (!createdDirs.has(dir)) {
        await fs_1.promises.mkdir(dir, { recursive: true });
        createdDirs.add(dir);
    }
    const temp = (0, path_temp_1.default)(dir);
    await graceful_fs_1.default.writeFile(temp, JSON.stringify(meta));
    await (0, rename_overwrite_1.default)(temp, pkgMirror);
}
function validatePackageName(pkgName) {
    if (pkgName.includes('/') && pkgName[0] !== '@') {
        throw new error_1.default('INVALID_PACKAGE_NAME', `Package name ${pkgName} is invalid, it should have a @scope`);
    }
}
//# sourceMappingURL=pickPackage.js.map